import java.util.*;
import java.util.Arrays;

public class Geffe{
    public static int[][] lfsr1=new int[32][5]; //a 2d array that contains all of the initial keys for lfrs1
    public static int index1=0; //represents current key in lfsr1
    public static int[] polinom1={1,0,0,1,0};
    public static int[][] lfsr2=new int[128][7]; //a 2d array that contains all of the initial keys for lfrs2
    public static int index2=0;
    public static int[] polinom2={1,0,0,0,0,0,1};
    public static int[][] lfsr3=new int[2048][11]; //a 2d array that contains all of the initial keys for lfrs3
    public static int index3=0;
    public static int[] polinom3={1,0,0,0,0,0,0,0,0,1,0};

    public static int[] calculate(int[] polinom, int[] key, int l){ //with this function we calculate 60 bits generated by a LFSR
        int[] result=new int[l];
        for(int i=0; i<key.length; i++)
            result[i]=key[i];
        for(int i=key.length; i<l; i++){
            int k=key.length-1;
            for(int j=i-1; j>=i-key.length; j--){
                result[i]=(result[i]+(polinom[k]*result[j])%2)%2;
                k--;
            }
        }
        return result;
    }

    public static int[] lfsr1Encoding(int[] geffevalues){
        //Go through all possible initial keys, then for each generate a 60bit long array,
        //then check if it is 75% correspondent to the geffe values that we hava, if yes, save the index of that row of 60 bits
        int[][] values=new int[32][60];
        int max=0;
        int indexofmax=0;
        for(int i=0; i<32; i++){
            values[i]=calculate(polinom1,lfsr1[i],60);
            int counter=0;
            for(int j=0; j<60; j++)
                if(values[i][j]==geffevalues[j])
                    counter++;
            if(counter>=45) //45 is 75% of 60
                 if(max<counter){
                    max=counter;
                    indexofmax=i;
                }
        }
        return lfsr1[indexofmax]; //returns the key that generates the stream that has the biggest correspondance to the geffe values
    }
    public static int[] lfsr3Encoding(int[] geffevalues){
        //Go through all possible initial keys, then for each generate a 60bit long zaporedje,
        // then check if it is 75% correspondent to the geffe values that we have, if yes, save the index of that row of 60 bits
        int[][] values=new int[2048][60];
        int max=0;
        int indexofmax=0;
        for(int i=0; i<2048; i++){
            values[i]=calculate(polinom3,lfsr3[i],60);
            int counter=0;
            for(int j=0; j<60; j++)
                if(values[i][j]==geffevalues[j])
                    counter++;
            if(counter>=45) //45 is 75% of 60
               if(max<counter){
                    max=counter;
                    indexofmax=i;
            }
        }
        return lfsr3[indexofmax]; //returns the key that generates the stream that has the biggest correspondance to the geffe values
    }

    public static int[] lfsr2Encoding(int[] geffevalues, int[] lfsr1key, int[] lfsr3key){
        int[] value=new int[60];
        for(int i=0; i<lfsr2.length; i++){
            value=calculateGeffe(calculate(polinom1,lfsr1key,60),calculate(polinom2,lfsr2[i],60),calculate(polinom3,lfsr3key,60),60);
            boolean check=true;
            int count=0;
            for(int j=0; j<60; j++)
                if(value[j]!=geffevalues[j]){
                    count++;
                    check=false;
                    break;
                }
            if(check)
                return lfsr2[i];

        }
        return lfsr2[0];
    }
    public static int[] calculateGeffe(int[] l1,int[] l2, int[] l3, int l){
        int[] rez=new int[l];
        for(int i=0; i<l; i++)
            rez[i]=((l1[i]*l2[i])%2 + (l2[i]*l3[i])%2 + l3[i])%2;
        return rez;
    }

    public static void initialKeys1(int[] bits, int i){ //it generates all possible initial keys of length 5
        if(i==5){
            for(int j=0; j<5; j++)
                lfsr1[index1][j]=bits[j];
            index1++;
            return;
        }
        bits[i]=0;
        initialKeys1(bits,i+1);
        bits[i]=1;
        initialKeys1(bits, i+1);
    }
    public static void initialKeys2(int[] bits, int i){ //it generates all possible initial keys of length 7
        if(i==7){
            for(int j=0; j<7; j++)
                lfsr2[index2][j]=bits[j];
            index2++;
            return;
        }
        bits[i]=0;
        initialKeys2(bits,i+1);
        bits[i]=1;
        initialKeys2(bits, i+1);
    }
    public static void initialKeys3(int[] bits, int i){ //it generates all possible initial keys of length 11
        if(i==11){
            for(int j=0; j<11; j++)
                lfsr3[index3][j]=bits[j];
            index3++;
            return;
        }
        bits[i]=0;
        initialKeys3(bits,i+1);
        bits[i]=1;
        initialKeys3(bits, i+1);
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int[][] numbers = new int[26][5]; //a 2d array of the letters represented in binary with 5 digits: row i is letter i: 0->a; 25->z, it is used for easir access to the letters
        for (int i = 0; i < 26; i++) {
            String s = Integer.toBinaryString(i);
            int index = 5 - s.length();
            int k = 0;
            for (int j = index; j < 5; j++) {
                numbers[i][j] = Integer.parseInt(String.valueOf(s.charAt(k)));
                k++;
            }
        }
        int[] cryptography = new int[60]; //the plaintext has 12 letters, each represented with 5 bits ->12*5=60 total number of bits
        String c = "CRYPTOGRAPHY";
        int i = 0;
        for (int j = 0; j < c.length(); j++) {
            int row = c.charAt(j) - 'A';
            for (int k = 0; k < 5; k++) {
                cryptography[i] = numbers[row][k];
                i++;
            }
        }

        String encryptedmessage = sc.nextLine();
        int[] encrypted = new int[encryptedmessage.length()]; //an array of all bits in the message
        for (int j = 0; j < encrypted.length; j++)
            encrypted[j] = Integer.parseInt(String.valueOf(encryptedmessage.charAt(j)));

        int[] shorttext=new int[60]; //only the first 60 bits from the encrypted message that we have in order to get values of Geffe genrator
        for(int j=0; j<60; j++)
            shorttext[j]=encrypted[j];

        int[] geffevalues=new int[60];
        for(int j=0; j<60; j++)
            geffevalues[j]=(encrypted[j]+cryptography[j])%2;

        initialKeys1(new int[5],0);
        initialKeys2(new int[7],0);
        initialKeys3(new int[11],0);

        //The initial keys for each lfsr separately:
        int[] lfsr1key=lfsr1Encoding(geffevalues);
        int[] lfsr3key=lfsr3Encoding(geffevalues);
        int[] lfsr2key=lfsr2Encoding(geffevalues,lfsr1key,lfsr3key);
        System.out.println("INITIAL KEY FOR LFSR1: ");
        for(int j=0; j<lfsr1key.length; j++)
            System.out.print(lfsr1key[j]);
        System.out.println();
        System.out.println("INITIAL KEY FOR LFSR2: ");
        for(int j=0; j<lfsr2key.length; j++)
            System.out.print(lfsr2key[j]);
        System.out.println();
        System.out.println("INITIAL KEY FOR LFSR3: ");
        for(int j=0; j<lfsr3key.length; j++)
            System.out.print(lfsr3key[j]);
        System.out.println();

        System.out.println("DECRYPTED MESSAGE: ");
        int[] r=calculateGeffe(calculate(polinom1,lfsr1key,encryptedmessage.length()),calculate(polinom2,lfsr2key,encryptedmessage.length()),calculate(polinom3,lfsr3key,encryptedmessage.length()),encryptedmessage.length());
        int[] finalresult=new int[r.length];
        for(int j=0; j<r.length; j++)
            finalresult[j]=(r[j]+encrypted[j])%2;

        for(int j=0; j<finalresult.length; j+=5){
            String crka=new String();
            for(int k=j; k<j+5; k++){
                crka+=Integer.toString(finalresult[k]);
                if(j>=finalresult.length)
                    break;
            }
            System.out.print((char)(Integer.parseInt(crka,2)+'A'));
        }
    }
}